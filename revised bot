import os
import json
import time
import requests
import pandas as pd
from datetime import datetime, timedelta, timezone
from coinbase.rest import RESTClient
from telegram import Update
from telegram.ext import Updater, MessageHandler, Filters, CallbackContext
import threading

# === Coinbase API ===
with open('cdp_api_key.json') as f:
    credentials = json.load(f)
API_KEY = credentials['name']
PRIVATE_KEY = credentials['privateKey']
client = RESTClient(api_key=API_KEY, api_secret=PRIVATE_KEY)

# === Secure Telegram Config ===
TELEGRAM_BOT_TOKEN = os.environ["TELEGRAM_BOT_TOKEN"]
TELEGRAM_CHAT_ID = os.environ["TELEGRAM_CHAT_ID"]  # string format

# === Global State ===
last_signal = {
    "coin": None,
    "position_open": False,
    "entry_price": None,
    "peak_price": None,
    "entry_time": None
}

coins = ['DOGE-USD', 'SHIB-USD', 'PEPE-USD', 'FLOKI-USD',
         'WIF-USD', 'SOL-USD', 'RNDR-USD', 'APT-USD',
         'OP-USD', 'COMP-USD']

# === Configurable Parameters ===
TRAILING_STOP_PCT = 0.10
RSI_SELL_THRESHOLD = 60

# === Telegram ===
def send_telegram_message(message):
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        params = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
        response = requests.post(url, params=params)
        return response.ok
    except Exception as e:
        print(f"Telegram error: {e}")
        return False

# === Trading Actions ===
def execute_buy(coin):
    print(f"üöÄ BUY EXECUTED: {coin}")
    send_telegram_message(f"üöÄ BUY EXECUTED: {coin}")
    last_signal["position_open"] = True
    last_signal["entry_time"] = datetime.now()

def execute_sell(coin, reason="Manual"):
    print(f"üîª SELL EXECUTED: {coin} ‚Äî Reason: {reason}")
    send_telegram_message(f"üîª SELL EXECUTED: {coin}\nReason: {reason}")
    last_signal["position_open"] = False
    last_signal["entry_price"] = None
    last_signal["peak_price"] = None
    last_signal["entry_time"] = None

# === Message Handler ===
def handle_response(update: Update, context: CallbackContext):
    user_id = str(update.effective_user.id)
    message_text = update.message.text.strip().lower()
    expected_coin = last_signal.get("coin")

    if user_id != TELEGRAM_CHAT_ID:
        update.message.reply_text("‚ùå Unauthorized.")
        return

    if not expected_coin:
        update.message.reply_text("‚ö†Ô∏è No active coin.")
        return

    if message_text == f"buy {expected_coin.lower()}":
        if last_signal["position_open"]:
            update.message.reply_text("‚ö†Ô∏è Position already open.")
        else:
            last_signal["entry_price"] = get_current_price(expected_coin + "-USD")
            last_signal["peak_price"] = last_signal["entry_price"]
            execute_buy(expected_coin)
            update.message.reply_text(f"‚úÖ Buying {expected_coin} at {last_signal['entry_price']:.4f}")

    elif message_text == f"sell {expected_coin.lower()}":
        if not last_signal["position_open"]:
            update.message.reply_text("‚ö†Ô∏è No open position.")
        else:
            execute_sell(expected_coin, "Manual")
            update.message.reply_text(f"‚úÖ Selling {expected_coin}")

    else:
        update.message.reply_text("‚ö†Ô∏è Use 'buy <coin>' or 'sell <coin>'.")

# === Listener ===
def start_listener():
    updater = Updater(TELEGRAM_BOT_TOKEN, use_context=True)
    dp = updater.dispatcher
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_response))
    updater.start_polling()
    print("üì¨ Telegram listener running...")
    updater.idle()

# === Coinbase Data ===
def get_current_price(coin):
    ticker = client.get_product_ticker(coin)
    return float(ticker['price'])

def get_daily_data(coin):
    end = datetime.now(timezone.utc)
    start = end - timedelta(days=7)
    response = client.get_candles(
        product_id=coin,
        granularity='ONE_DAY',
        start=int(start.timestamp()),
        end=int(end.timestamp())
    )
    candles = response.candles
    df = pd.DataFrame([{
        'date': pd.to_datetime(int(c['start']), unit='s'),
        'open': float(c['open']),
        'close': float(c['close']),
        'volume': float(c['volume'])
    } for c in candles])
    df.sort_values('date', inplace=True)
    return df

def compute_rsi(prices, window=14):
    delta = prices.diff()
    up, down = delta.clip(lower=0), -delta.clip(upper=0)
    avg_gain = up.rolling(window=window).mean()
    avg_loss = down.rolling(window=window).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def check_signal(df):
    if len(df) < 2:
        return False, 0, 0
    yesterday = df.iloc[-2]
    avg_volume = df['volume'][:-1].mean()
    price_change = (yesterday['close'] - yesterday['open']) / yesterday['open']
    volume_change = yesterday['volume'] / avg_volume
    return (price_change >= 0.10 and volume_change >= 1.5), price_change, volume_change

# === Auto Sell Logic ===
def auto_sell_check():
    if not last_signal["position_open"]:
        return
    coin = last_signal["coin"]
    coin_pair = f"{coin}-USD"
    current_price = get_current_price(coin_pair)
    last_signal["peak_price"] = max(last_signal["peak_price"], current_price)

    # Trailing stop
    if current_price < last_signal["peak_price"] * (1 - TRAILING_STOP_PCT):
        execute_sell(coin, "Trailing Stop Trigger")
        return

    # RSI breakdown
    df = get_daily_data(coin_pair)
    df['rsi'] = compute_rsi(df['close'])
    if len(df) > 1:
        rsi_today = df['rsi'].iloc[-1]
        rsi_yesterday = df['rsi'].iloc[-2]
        if rsi_yesterday >= RSI_SELL_THRESHOLD and rsi_today < RSI_SELL_THRESHOLD:
            execute_sell(coin, "RSI Breakdown Trigger")

# === Main Trading Bot ===
def main():
    while True:
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print(f"Running at {now}")
        try:
            auto_sell_check()
            for coin in coins:
                df = get_daily_data(coin)
                signal, price_chg, vol_chg = check_signal(df)
                if signal:
                    coin_short = coin.split("-")[0]
                    msg = (f"üö® Momentum Signal!\n"
                           f"{coin}\n"
                           f"Price: {price_chg*100:.2f}%, Volume: {vol_chg*100:.2f}%\n"
                           f"Reply: buy {coin_short}")
                    send_telegram_message(msg)
                    last_signal.update({
                        "coin": coin_short,
                        "position_open": False,
                        "entry_price": None,
                        "peak_price": None,
                        "entry_time": None
                    })
                    break  # Signal found, skip the rest
        except Exception as e:
            print(f"‚ö†Ô∏è Error: {e}")
        time.sleep(3600)  # Run every hour

# === Entry ===
if __name__ == "__main__":
    threading.Thread(target=main).start()
    start_listener()
